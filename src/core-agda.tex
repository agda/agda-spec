\documentclass[acmlarge]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{mathpartir}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\proj}{proj}
\renewcommand{\|}{\mid}


\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{1}
\acmArticle{1}
\acmYear{2017}
\acmMonth{1}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\else\makeatother
%% Conference information (used by SIGPLAN proceedings format)
%% Supplied to authors by publisher for camera-ready submission
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}
\fi


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\setcopyright{none}             %% For review submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\RequirePackage{ifthen}
\RequirePackage{amssymb}
\RequirePackage{amsfonts}
\RequirePackage{stmaryrd} % \shortuparrow


\input{macros}


\begin{document}

%% Title information
\title[Core Agda]{Specification of Core Agda}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{Subtitle}                     %% \subtitle is optional
\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
 x

%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}
}
\email{first2.last2@inst2b.org}         %% \email is recommended


%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
This document specifies the abstract syntax, evaluation rules, and
typing rules of Core Agda, the basic type theory underlying Agda.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Agda, dependent types, specification}  %% \keywords is optional


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

Agda 2 has been developed since 2005, and been released 2007.  So far,
no specification has been given.  This document attempts to specify
the core components of Agda.


\section{Syntax}
\label{sec:syntax}

\newcommand{\bang}{\,!\,}
\newcommand{\twobang}{\,!!\,}


Names
\[
\begin{array}{ll}
D   & \hspace{2cm}\text{Datatype name} \\
  R & \hspace{2cm}\text{   Record type name} \\
  f & \hspace{2cm}\text{   Function name} \\
\pi & \hspace{2cm}\text{  Projection name  (overloaded)} \\
  c & \hspace{2cm}\text{   Constructor name (overloaded)} \\
\end{array}
\]

Variables (represented by a de Bruijn-index)
\[
x,y,z, \hdots
\]

Data/record type name
\[
\begin{array}{lrl}
F &::= & D \\& |& R
\end{array}
\]

Terms ($\beta$-normal).
\[
\begin{array}{lrll}
t, u, v &::=& x\; \bar{e}            & \hspace{2cm}\text{Variables (eliminated by $\bar{e}$)} \\
          &|& c\; \bar{v}            & \hspace{2cm}\text{Constructor applied to arguments $\bar{v}$} \\
          &|& f\; \bar{e}            & \hspace{2cm}\text{Defined function (eliminated by $\bar{e}$), includes postulates} \\
          &|& \lambda x.\, v           & \hspace{2cm}\text{Lambda abstraction} \\
          &|& F\; \bar{v}            & \hspace{2cm}\text{Data/record type} \\
          &|& s               & \hspace{2cm}\text{Sort} \\
          &|& (x : U) \rightarrow V      & \hspace{2cm}\text{Dependent function type} \\
\end{array}
\]

Eliminations.
\[\begin{array}{lrll}
e &::=& @u                & \hspace{2cm}\text{Application to term} \\
    &|& .\pi               & \hspace{2cm}\text{ Projection} \\
\end{array} \]

Sorts.
\[\begin{array}{lrll}
s ::= \Set_n             & \hspace{2cm} \text{Universe of types of level $n$} \\
\end{array} \]
We define \fbox{$s \sqcup s'$} by $\Set_i \sqcup \Set_j = \Set_{\max(i,j)}$.

Telescopes.
\[\begin{array}{lrll}
\Delta &::=& ·  & \\
      &  |& (x : T)\Delta & \\
\end{array} \]

Iterated function types $\Delta \rightarrow T$
\[\begin{array}{lrll}
· \rightarrow T &=& T &\\
(x : U)\Delta \rightarrow T &=& (x : U) \rightarrow (\Delta \rightarrow T) & \\
\end{array} \]


\section{Declarations}
\label{sec:declarations}

Copattern
\[\begin{array}{lrll}
q &::=& @p &\\
  &  |& .\pi \\
\end{array} \]

Pattern
\[\begin{array}{lrll}
p &::=& x     &  \hspace{2cm} \text{Variable pattern} \\
    &|& c\; \bar{p}    &  \hspace{2cm} \text{Constructor pattern} \\
    &|& .u      &  \hspace{2cm} \text{Dot pattern} \\
\end{array} \]

Declarations
\[
\begin{array}{lrll}
d  & ::=  & \mathit{ts} & \mbox{type signature}
\\ & \mid & \mathit{cl} & \mbox{function clause}
\\ & \mid & \mathit{ds} & \mbox{data signature}
\\ & \mid & \mathit{dd} & \mbox{data definition}
\\ & \mid & \mathit{rs} & \mbox{record signature}
\\ & \mid & \mathit{rd} & \mbox{record definition}

\end{array}
 \]

Type signatures
\[\begin{array}{lrll}
ts &::=& f : T &\\
\end{array} \]

Function clauses
\[\begin{array}{lrll}
cl &::=& f\; \bar{q} = t &\\
\end{array} \]

Data signature
\[
\textbf{data}\; D\; \Delta : \Delta' \rightarrow s
\]

Data definition
\[
\textbf{data}\; D\; \Delta \;\textbf{where}\; \overline{c : T}
\]

Record signature
\[ \begin{array}{l}
\textbf{record}\; R\; \Delta : s
\end{array}\]

Record declaration
\[ \begin{array}{l}
\textbf{record}\; R\; \Delta \; \textbf{where} \\
\qquad  \textbf{constructor}\; c \\
\qquad  \textbf{field}\; \overline{\pi : T} \\
\end{array}\]




\section{Evaluation}
\label{sec:evaluation}

\newcommand{\datasig}{\text{data } D\; \Delta : \Delta' \to s \text{ where } \overline{c : T}}
\newcommand{\recsig}{\text{record } R\;\Delta : s \text{ where
    $c : T$; } \text{projections } \overline{\pi : T} }
\newcommand{\funsig}{\text{function } f : T \text{ where } \overline{cl}}

A signature is a list of signature declarations (used internally).
\[
\begin{array}{lcl}
\Sigma & ::= &  \overline{d_\Sigma} \\
d_\Sigma & ::= & \datasig \\
& \| & \recsig \\
& \| & \funsig
\end{array}
\]


Hereditary substitution \fbox{$u[\sigma] = v$}
and elimination \fbox{$t \bang \overline{e} = v$}\ .
\begin{gather*}
\inferrule
  {\sigma(x) \bang \overline{e}[\sigma] = v}
  {x \overline{e}[\sigma] = v}
\qquad
\inferrule
  {\overline{e}[\sigma] = \overline{e}'}
  {f \overline{e}[\sigma] = f \overline{e}'}
\qquad
\cdots
\end{gather*}
\begin{gather*}
\inferrule
  { v[u/x] \bang \overline{e} = v'}
  {\lambda x.v \bang @u \overline{e} = v'}
\qquad
\inferrule
  {v_i ! \overline{e} = v'}
  {\cpi \overline{v} \bang .\pi_i \overline{e} = v'}
\\
\ru{}{t \bang \cdot = t}
\qquad
\ru{}{x \overline{e} \bang \overline{e}' = x \overline{e}
  \overline{e}'}
\qquad
\ru{}{f \overline{e} \bang \overline{e}' = f \overline{e} \overline{e}'}
\qquad
\ru{}{z \overline{v} \bang @ \overline{u} = z \overline{v}
  \overline{u}}\ z ::= c \mid D \mid R
% \qquad
% \ru{}{D \overline{v} \bang @ \overline{u} = D \overline{v}
%   \overline{u}}
% \qquad
% \ru{}{R \overline{v} \bang @ \overline{u} = R \overline{v} \overline{u}}
\end{gather*}
% \[
% \[
% \begin{array}{ll}
% &
% \\
% &
% \\
% \inferrule{c \overline{v} u \bang \overline{e} = v'}
% {\overline{v} \bang @u \overline{e} = v'}
% &
% \\
% &
% \text{ everything else undefined }
% \end{array}
% \]



Matching \fbox{$\Sigma \vdash e/q = \sigma$}\ .
\begin{gather*}
\ru{}{\Sigma \vdash v/\lfloor u \rfloor = \cdot} % dot pattern
\qquad
\ru{}{\Sigma \vdash v/x = [v/x]} % var pat
\qquad
\ru
  {\Sigma \vdash \overline{v}/\overline{\sigma} = \sigma}
  {\Sigma \vdash c\overline{v}/c\overline{p} = \sigma}  % con pat
\qquad
\ru{v \bang \pi_i / p_i = \sigma}
{\Sigma \vdash v / \cpi \overline{p} = \sigma} % record pat
\qquad
\ru{}{\Sigma \vdash .\pi/.\pi = \cdot} % proj pat
\\
\ru{\Sigma \vdash v \to v' \qquad \Sigma \vdash v'/c\overline{p} = \sigma}
{\Sigma \vdash v / c \overline{p} = \sigma} % reduce
\end{gather*}
% \[
% \begin{array}{ll}
% \overline{e}/\overline{q} = \sigma  &
% \Sigma \vdash e/q = \sigma
% \end{array}
% \]

% \[
% \begin{array}{ll}
% \inferrule{}
% {\Sigma \vdash v/\lfloor u \rfloor = \cdot} % dot pattern
% &
% \inferrule{}
% {\Sigma \vdash v/x = [v/x]} % var pat
% \\
% \inferrule{\Sigma \vdash \overline{v}/\overline{\sigma} = \sigma}
% {\Sigma \vdash c\overline{v}/c\overline{p} = \sigma}  % con pat
% &
% \inferrule{}
% {\Sigma \vdash .\pi/.\pi = \cdot} % proj pat
% \\
% \inferrule{\Sigma \vdash v \to v' \qquad \Sigma \vdash v'/c\overline{p} = \sigma}
% {\Sigma \vdash v / c \overline{p} = \sigma} % reduce
% &
% \inferrule{v \bang \pi_i / p_i = \sigma}
% {\Sigma \vdash v / c_{\overline \pi} \overline{p} = \sigma} % record pat
% \end{array}
% \]

Weak head reduction \fbox{$\Sigma \vdash t \to t'$}
\[
\begin{array}{lll}
\inferrule{f \overline q = t \in \Sigma \qquad \Sigma \vdash \overline{e}/\overline{q} = \sigma}
{\Sigma \vdash f \overline{e} \overline{e}' \to t[\sigma] \bang \overline{e}'}
&
\ru{}
{\Sigma \vdash \cdot/\cdot = \cdot} %empty
&
\inferrule{\Sigma \vdash e/q = \sigma \qquad \Sigma \vdash \overline{e}/\overline{q} = \sigma'}
{\Sigma \vdash e, \overline{e}/q, \overline{q} = \sigma \uplus \sigma'}%patterns
\end{array}
\]


\section{Typing rules}
\label{sec:typing}


\subsection{Auxiliary judgements}

Function type application \fbox{$T !! \vec u = U$}.
\[
  \ru{}{T !! . = T}
\qquad
  \ru{\subst u x V !! \vec u = T
    }{\funT x U V !! u \vec u = T}
\]

% Type elimination \fbox{$\Sigma \der (t : T) !! e = U$}.
% \[
%   \ru{}{\Sigma \der (t : \funT x U V) !! @u = \subst u x V}
% \qquad
%   \ru{\Sigma \der R.\pi : U
%     }{}
% \]

Signature lookup \fbox{$\Sigma \der z : T$}.
\begin{gather*}
  \ru{\funsig \in \Sigma
    }{\Sigma \der f : T}
\\
  \ru{\datasig \in \Sigma
    }{\Sigma \der D : \Delta \to \Delta' \to s}
\qquad
  \ru{\datasig \in \Sigma
    }{\Sigma \der D.c_i : \Delta \to T_i}
\\
  \ru{\recsig \in \Sigma
    }{\Sigma \der R : \Delta \to s}
\\
  \ru{\recsig \in \Sigma
    }{\Sigma \der R.c : \Delta \to T}
\qquad
  \ru{\recsig \in \Sigma
    }{\Sigma \der R.\pi_i : \Delta \to T_i}
\end{gather*}




\subsection{Typing judgements for expressions}


Typing contexts.
\[
\begin{array}{lcl}
\Gamma & ::= & \cdot \| \Gamma, x:T \\
\Delta & ::= & \cdot \| x:T, \Delta
\end{array}
\]

Well-typed contexts \fbox{$\vdash_\Sigma \Gamma$}.
\[
% Contexts
\ru{}{\vdash_\Sigma \cdot}
\qquad
\inferrule
  {\vdash_\Sigma \Gamma \qquad \Gamma \vdash_\Sigma T:s}
  {\vdash_\Sigma \Gamma, x : T} \ x \not\in \dom(\Gamma)
\]

Well-typed telescopes \fbox{$\Gamma \vdash_\Sigma \Delta$}.
\[
% Telescopes
\inferrule
  {\vdash_\Sigma \Gamma}
  {\Gamma \vdash_\Sigma \cdot}
\qquad
\inferrule{\Gamma \vdash_\Sigma T : s \qquad \Gamma, x:T \vdash_\Sigma \Delta}
{\Gamma \vdash_\Sigma (x:T) \Delta}
% \qquad x \in \dom{\Delta} \\
\]

Spine typing \fbox{$\Gamma \| u : U \vdash \overline{e} : T$}
($u$ is neutral).
\begin{gather*}
% Check spine
\ru{}
{\Gamma \| u:U \vdash \cdot : U}
\\
\inferrule
  {\Gamma \vdash u:U \qquad \Gamma \| t@u:T[u/x] \vdash \overline{e} : V}
  {\Gamma \| t : \Pi x:U.T \vdash @u \overline{e}:V}
\qquad
\ru{\Sigma \der R.\pi = T \qquad
    T !! (\vec u,t) = U \qquad
    \Gamma \| t.\pi : U \vdash_\Sigma \overline{e} : V
  }{\Gamma \| t : R \overline{u}  \vdash_\Sigma .\pi \overline{e} : V}
% \inferrule{ \Gamma \vdash (t:R\overline{u}).\pi = T'
% \qquad \Gamma \| t.\pi :T' \vdash_\Sigma \overline{e}:V}
% { \Gamma \| t : R \overline{u}  \vdash_\Sigma .\pi \overline{e}:V}
% \\
% \Sigma \vdash (t:R\overline{u}).\pi = T
% \\
% (t: \Sigma x:A.B).\proj_2 = B[t.\proj_1/x] &
% \\
% \inferrule{T[u/x] \twobang \overline{e} = v}
% {(\Pi x:U.T) \twobang @ u \overline{e} = v}
\\
\ru{\Gamma \mid u : U \vdash \vec e : V \qquad
    \Gamma \der U = U' : s
  }{\Gamma \mid u : U' \vdash \vec e : V}
\end{gather*}


Term typing \fbox{$\Gamma \vdash_\Sigma t : T$}
\begin{gather*}
\inferrule
  {(x:U)\in \Gamma \qquad \Gamma \mid x:U \vdash \overline{e}:T}
  {\Gamma \vdash x \overline{e} : T}
\qquad
\ru{\Sigma \vdash f : T \qquad
    \Gamma \mid f : T \vdash_\Sigma \vec e : V
   }{\Gamma \der_\Sigma f \vec e : V}
\\
\ru{\Sigma \der D.c : T \qquad
    T !! \vec u = T' \qquad
    \Gamma \mid c : T' \der_\Sigma \vec v : D \, \vec u \, \vec t
  }{\Gamma \der_\Sigma c\,\vec v : D\,\vec u\,\vec t}
\qquad
\ru{\Sigma \vdash z : T \qquad
    \Gamma \mid z : T \vdash_\Sigma \vec u : V
   }{\Gamma \der_\Sigma z \, \vec u : V} \ z ::= D \mid R
\\
\ru{\Gamma, x \of U \der_\Sigma v : V
  }{\Gamma \der_\Sigma \lambda x.v : \funT x U V}
\qquad
\ru{\Gamma \der U : s \qquad
    \Gamma, x \of U \der V : s'
  }{\Gamma \der \piT x U V : s \sqcup s'}
\end{gather*}


Conversion
\fbox{$\Gamma \vdash_\Sigma t = t' : T$}\ .
\begin{gather*}
%
\ru{\Sigma \der t \red t' \qquad
    \Gamma \ders t : T \qquad
    \Gamma \ders t' : T
  }{\Gamma \ders t = t' : T}
\\
\ru{\Gamma \ders t : \funT x U V
  }{\Gamma \ders t = \lambda x. t\, x : \funT x U V}
\qquad
\ru{\Gamma \ders t : R\, \vec u \qquad
    \Sigma \der R.\cpi : T
  }{\Gamma \ders t = \cpi\,\overline{t .\pi} : R\,\vec u}
\\
\end{gather*}
And many boring rules (equivalence, congruence)
and rules for elimination equality
\fbox{$\Gamma \mid t : T \ders \vec e = \vec e' : V$}


\subsection{Declaration typing}

(Co)pattern variables \fbox{$PV(p) = \bar{x}$}
\begin{gather*}
PV(x) = \{ x \} \qquad PV (\lceil v \rceil) = \emptyset \qquad PV(c\; \bar{p}) = PV(\bar{p}) \\
PV(\bar{p}) = \biguplus_i PV(p_i) \\
PV(.\pi) = \emptyset \qquad PV(@p) = PV(p) \\
PV(\bar{q}) = \biguplus_i PV(q_i) \\
\end{gather*}


Embedding of (co)patterns into terms \fbox{$\lceil p \rceil = t$}
\begin{gather*}
\lceil x \rceil = x \qquad
\lceil \lfloor v \rfloor \rceil = v \qquad
\lceil c\; \bar{p} \rceil = c\; \lceil \bar{p} \rceil \\
\lceil .\pi \rceil = .\pi \qquad
\lceil @p \rceil = @ \lceil p \rceil
\end{gather*}


%Pattern typing \fbox{$\Gamma \ders p : U \leadsto \Gamma'$}
%\begin{gather*}
%\ru{\Gamma \ders U : s}
%   {\Gamma \ders x : U \leadsto (x : U)} x \not\in dom(\Gamma) \\
%\ru{\Sigma \der D.c : T \qquad T!!\bar{u} = T' \qquad \Gamma \| c : T \ders @\bar{p} : D\; \bar{u}\; \bar{v} \leadsto \Gamma'}
%   {\Gamma  \ders c\; \bar{p} : D\; \bar{u}\; \bar{v} \leadsto \Gamma'}
%\end{gather*}
%
%
%Copattern typing \fbox{$\Gamma \| f : T \ders \bar{q} : U \leadsto \Gamma'$}
%\begin{gather*}
%\ru{\Gamma \vdash p : U \leadsto \Gamma_1 \qquad \Gamma,\Gamma' | h\; @p : V[p/x] \ders \bar{q} : T  \leadsto \Gamma_2}
%   {\Gamma \| h : \piT x U V \ders @p\; \bar{q} : T \leadsto \Gamma_1 , \Gamma_2}
%\end{gather*}

Clause typing \fbox{$f : T \ders cl$}
\begin{gather*}
\ru{PV(\bar{q}) = dom(\Gamma) \qquad
    \Gamma | f : T \ders \lceil \bar{q} \rceil : U \qquad
    \Gamma \ders t : U}
   {f : T \ders f\; \bar{q} = t}
\end{gather*}

Constructor typing \fbox{$\Delta | U : \Delta' \rightarrow s \ders c : T$}
\begin{gather*}
\ru{\Delta \ders \Gamma \rightarrow T : s \qquad
    \Delta,\Gamma \ders \bar{v} : \Delta' \qquad
    \Delta,\Gamma \ders T = U\; \bar{v} : s}
   {\Delta | U : \Delta' \rightarrow s \ders c : \Gamma \rightarrow T}
\end{gather*}

% TODO: add syntax for lone declarations without a definition (i.e. with no 'where').
Declaration typing \fbox{$\Sigma \der d \leadsto \Sigma'$}
\begin{gather*}
\ru{f \not\in \Sigma \qquad \cdot \ders T : s}
   {\Sigma \der f : T \leadsto \Sigma, function\; f : T\; where\; \cdot}
\\
\ru{\forall i.\; f : T \ders cl_i}
   {\Sigma[function\; f : T\; where\; \cdot] \der \overline{cl} \leadsto \Sigma[function\; f : T\; where\; \overline{cl}]}
\\
\ru{D \not\in \Sigma \qquad \ders \Delta \qquad \Delta \ders \Delta'}
   {\Sigma \der data\; D\; \Delta : \Delta' \rightarrow s \leadsto \Sigma, data\; D\; \Delta : \Delta' \rightarrow s}
\\
\ru{\forall i.\; \Delta | D\; \Delta : \Delta' \rightarrow s \vdash c_i : T_i}
   {\Sigma[data\; D\; \Delta : \Delta' \rightarrow s] \ders data\; D\; \Delta\; where\; \overline{c : T} \leadsto \Sigma[data\; D\; \Delta : \Delta' \rightarrow s\; where\; \overline{c : T}]}
\\
\ru{R \not\in \Sigma \qquad \ders \Delta}
   {\Sigma \ders record\; R \; \Delta : s \leadsto \Sigma, record\; R\; \Delta : s}
\\
\ru{\Delta \ders \overline{(\hat{\pi} : T)} \rightarrow R\; \Delta : s \qquad
    U_i = \Delta \rightarrow (x : R\; \Delta) \rightarrow T_i[x.\pi_j / \hat{\pi_j}] }
   {\Sigma[record\; R\; \Delta : s] \ders record\; R\; \Delta\; where\; constructor\; c, \overline{field\; \hat{\pi} : T} \\  \leadsto \Sigma[record\; R\; \Delta : s\; where\; c : \Delta \rightarrow \overline{(\pi : T)} \rightarrow R\; \Delta; projections\; \overline{\pi : U}]} x \not\in dom(\Delta)
\end{gather*}







\section{Coverage}
\label{sec:coverage}

\section{Termination}
\label{sec:termination}

\section{Positivity}
\label{sec:positivity}

\section{Extensions}
\label{sec:extensions}

\subsection{Extended record declarations}

Record types
\begin{verbatim}
record R Γ : s where
  [constructor c]
  [(co)inductive]
  [(no-)eta-equality]
  rd*
\end{verbatim}

Record declaration
\begin{verbatim}
rd ::= field π : T
     | ts
     | cl
\end{verbatim}


%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
  This material is based upon work supported by the
  \grantsponsor{GS100000001}{National Science
    Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
  No.~\grantnum{GS100000001}{nnnnnnn} and Grant
  No.~\grantnum{GS100000001}{mmmmmmm}.  Any opinions, findings, and
  conclusions or recommendations expressed in this material are those
  of the author and do not necessarily reflect the views of the
  National Science Foundation.
\end{acks}


%% Bibliography
%\bibliography{bibfile}


%% Appendix
% \appendix
% \section{Appendix}


\end{document}
